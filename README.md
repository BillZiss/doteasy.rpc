# Introduction
With the continuous development of the website system, the complexity of the architecture will change from MVC->SOA->microservices, from simple to complex, from centralized to distributed.
The introduction of the service framework is SOA->microservice process The problem that must be solved.
In the face of the increase in services, the deployment of service distribution, the mutual call between services and services, have to use the service framework to solve.
Based on NET Core 2.0 Standard 2 development, DotEasy.RPC supports transparent calls from the client to the server, just as simple as an implementation call to an interface.


# Features and dependence
1. Automate assembly and construction of related component types using Microsoft.Extensions.Dependency Injection (future considerations modified to Autofac).
2. Serialization of byte streams using [protobuf-net](https://github.com/mgravell/protobuf-net)
3. Generated by [Roslyn](https://github.com/dotnet/roslyn)'s runtime client proxy 
4. Communication pipeline and host built on [DotNetty](https://github.com/Azure/DotNetty)


# More
[http://www.cnblogs.com/SteveLee/](http://www.cnblogs.com/SteveLee/)


# How to use
**step 1:**
Download the nuget package and install you project, input the code: 
```
Install-Package DotEasy.Rpc -Version 1.0.1
```
or clone the doteasy.rpc source code package.
* Note the project dependent installation

**step 2:**
* Separate your interface and implementation. For example, the interface class name is 'ISample', which contains an interface method 'string SayHello(string name)', the code is as followsï¼š
```
[RpcTagBundle]
public interface ISample
{
    string SayHello(string name);
    ...n
}
```
_**At the 'ISample' interface project or other interface, you must ensure that only the interface definition is in the project.**_
_**Must be on the interface add property name 'RpcTagBundle'.**_
* And in the implementation class name 'Sample'
```
public Sample : ISample
{
    string SayHello(string name)
    {
        return $"hello {name}";
    }
}
```

**step 3:**

Applications were established server and client, the server recommended asp.net core to create a client at random, you can use asp.net core, or use the console application, or even the use of .net winform and so support
* At the asp.net core use middlware extend the package before reference the 'Isample' project and 'DotEasy.Rpc.Entry' dependency package, of course, you can also write your own build method. 
For example in the server:
```
app.UseConsulServerExtensions(Configuration,
    collection =>
    {
        collection.AddSingleton<IProxyService, ProxyImpl>();
    },
    typeof(AuthorizationServerProvider)
);
```
for example in the console appliaction, you need to quote the 'Entry' lazy package, or you can also write your own build method:
```
using (var proxy = ClientProxy.Generate<IProxyService>(new Uri("http://127.0.0.1:8500")))
{
    Console.WriteLine($@"{proxy.Sync(1)}");
    Console.WriteLine($@"{proxy.Async(1).Result}");
    Console.WriteLine($@"{proxy.GetDictionaryAsync().Result["key"]}");
}
```
_**Just need to reference the interface project, not the implementation project**_

**step 4:**

you can start register service 'consul' or 'etcd' completed, and start client program before start you asp.net core web server, running the result is 'hello world'.


# Change log
## 1.0.2
1. Added precompiled synchronous and asynchronous remote invocation methods, unforcing the use of Task as asynchronous calls and precompiled builds.

## 1.0.1
1. Added Consul registration and callback to implement the configuration of the Consul registry.
2. Added Entry lazy entry class library package to implement Asp.net middleware extension and host based on Console application.

# Next version expectation 1.0.3
1. Replace Microsoft.Extensions.Dependency with Autofac, support batch import of qualified names and improve Ioc container performance.
2. When the 500+ interface(or service) is pre-compiled client(or consumer), the total time needs to be shortened to solve the suspended caused by large-scale pre-compilation.
3. interface auto disponse.
